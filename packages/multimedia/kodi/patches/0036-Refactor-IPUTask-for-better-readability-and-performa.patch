From 3c7ee4e10ab3bab6fc3dd0ad8f375b9112d9093f Mon Sep 17 00:00:00 2001
From: Rudi <r.ihle@s-t.de>
Date: Sat, 24 Sep 2016 16:13:51 +0200
Subject: [PATCH 36/37] Refactor IPUTask for better readability and performance

---
 .../DVDCodecs/Video/DVDVideoCodecIMX.cpp           | 144 ++++++++++-----------
 .../VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h |  26 ++--
 2 files changed, 82 insertions(+), 88 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
index 1ea4922..3535c09 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
@@ -1547,24 +1547,24 @@ void CIMXContext::Blit(CIMXBuffer *source_p, CIMXBuffer *source, const CRect &sr
   else if (page < 0 || page >= m_fbPages)
     return;
 
-  IPUTaskPtr ipu(new IPUTask(source_p, source, page));
+  IPUTask task(source_p, source, page);
   pg = (page + 1) % m_fbPages;
 
 #ifdef IMX_PROFILE_BUFFERS
   unsigned long long before = XbmcThreads::SystemClockMillis();
 #endif
   SetFieldData(fieldFmt, source->m_fps);
-  PrepareTask(ipu, srcRect, dstRect);
+  PrepareTask(task, srcRect, dstRect);
 
-  if (!DoTask(ipu))
+  if (!DoTask(task))
     return;
 
-  m_flip = ipu->page | checkIPUStrideOffset(&ipu->task.input.deinterlace) << 4;
+  m_flip = task.targetPage | checkIPUStrideOffset(&task.input.deinterlace) << 4;
   m_waitFlip.Set();
 
 #ifdef IMX_PROFILE_BUFFERS
   unsigned long long after = XbmcThreads::SystemClockMillis();
-  CLog::Log(LOGDEBUG, "+P 0x%x@%d  %d\n", ((CDVDVideoCodecIMXBuffer*)ipu->current)->GetIdx(), ipu->page, (int)(after-before));
+  CLog::Log(LOGDEBUG, "+P 0x%x@%d  %d\n", ((CDVDVideoCodecIMXBuffer*)task.currBuf)->GetIdx(), task.targetPage, (int)(after-before));
 #endif
 }
 
@@ -1644,7 +1644,7 @@ void CIMXContext::Clear(int page)
   SetProcessInfo(m_processInfo);
 }
 
-void CIMXContext::PrepareTask(IPUTaskPtr &ipu, CRect srcRect, CRect dstRect)
+void CIMXContext::PrepareTask(IPUTask &task, CRect srcRect, CRect dstRect)
 {
   CRectInt iSrcRect, iDstRect;
 
@@ -1689,78 +1689,78 @@ void CIMXContext::PrepareTask(IPUTaskPtr &ipu, CRect srcRect, CRect dstRect)
   iDstRect.x2 = Align2((int)dstRect.x2,8);
   iDstRect.y2 = Align2((int)dstRect.y2,8);
 
-  ipu->task.input.crop.pos.x  = iSrcRect.x1;
-  ipu->task.input.crop.pos.y  = iSrcRect.y1;
-  ipu->task.input.crop.w      = iSrcRect.Width();
-  ipu->task.input.crop.h      = iSrcRect.Height();
+  task.input.crop.pos.x  = iSrcRect.x1;
+  task.input.crop.pos.y  = iSrcRect.y1;
+  task.input.crop.w      = iSrcRect.Width();
+  task.input.crop.h      = iSrcRect.Height();
 
-  ipu->task.output.crop.pos.x = iDstRect.x1;
-  ipu->task.output.crop.pos.y = iDstRect.y1;
-  ipu->task.output.crop.w     = iDstRect.Width();
-  ipu->task.output.crop.h     = iDstRect.Height();
+  task.output.crop.pos.x = iDstRect.x1;
+  task.output.crop.pos.y = iDstRect.y1;
+  task.output.crop.w     = iDstRect.Width();
+  task.output.crop.h     = iDstRect.Height();
 
   // Setup deinterlacing if enabled
-  if (m_currentFieldFmt && ipu->previous)
+  if (m_currentFieldFmt && task.prevBuf)
   {
-    ipu->task.input.deinterlace.enable = 1;
-    ipu->task.input.deinterlace.motion = m_motion;
-    ipu->task.input.deinterlace.field_fmt = m_currentFieldFmt;
+    task.input.deinterlace.enable = 1;
+    task.input.deinterlace.motion = m_motion;
+    task.input.deinterlace.field_fmt = m_currentFieldFmt;
   }
 }
 
-bool CIMXContext::TileTask(IPUTaskPtr &ipu)
+bool CIMXContext::TileTask(IPUTask &task)
 {
-  int pad = ipu->task.input.height == 1080 && ipu->current->iHeight>ipu->task.input.height ? 16*ipu->current->iWidth : 0;
+  int pad = task.input.height == 1080 && task.currBuf->iHeight>task.input.height ? 16*task.currBuf->iWidth : 0;
   m_zoomAllowed = true;
 
-  if (ipu->current->iFormat != _4CC('T', 'N', 'V', 'F') && ipu->current->iFormat != _4CC('T', 'N', 'V', 'P'))
+  if (task.currBuf->iFormat != _4CC('T', 'N', 'V', 'F') && task.currBuf->iFormat != _4CC('T', 'N', 'V', 'P'))
   {
-    if (ipu->task.input.deinterlace.enable && ipu->task.input.deinterlace.motion != HIGH_MOTION)
+    if (task.input.deinterlace.enable && task.input.deinterlace.motion != HIGH_MOTION)
     {
-      ipu->task.input.paddr_n = ipu->task.input.paddr;
-      ipu->task.input.paddr   = ipu->previous->pPhysAddr + pad;
+      task.input.paddr_n = task.input.paddr;
+      task.input.paddr   = task.prevBuf->pPhysAddr + pad;
     }
     else
-      ipu->task.input.paddr  += pad;
+      task.input.paddr  += pad;
     return true;
   }
 
   // Use band mode directly to FB, as no transformations needed (eg cropping)
-  if (m_fps >= 49 && m_fbWidth == 1920 && ipu->task.input.width == 1920 && !ipu->task.input.deinterlace.enable)
+  if (m_fps >= 49 && m_fbWidth == 1920 && task.input.width == 1920 && !task.input.deinterlace.enable)
   {
     m_zoomAllowed = false;
-    ipu->task.output.crop.pos.x = ipu->task.input.crop.pos.x = 0;
-    ipu->task.output.crop.pos.y = ipu->task.input.crop.pos.y = 0;
-    ipu->task.output.crop.h     = ipu->task.input.height     = ipu->task.input.crop.h = ipu->current->iHeight;
-    ipu->task.output.paddr     += m_fbLineLength * (m_fbHeight - ipu->task.input.crop.h)/2;
+    task.output.crop.pos.x = task.input.crop.pos.x = 0;
+    task.output.crop.pos.y = task.input.crop.pos.y = 0;
+    task.output.crop.h     = task.input.height     = task.input.crop.h = task.currBuf->iHeight;
+    task.output.paddr     += m_fbLineLength * (m_fbHeight - task.input.crop.h)/2;
     return true;
   }
   // rasterize from tile (frame)
   struct ipu_task    vdoa;
 
-  memset(&vdoa, 0, sizeof(ipu->task));
-  vdoa.input.width   = vdoa.output.width  = ipu->current->iWidth;
-  vdoa.input.height  = vdoa.output.height = ipu->current->iHeight;
-  vdoa.input.format  = ipu->current->iFormat;
+  memset(&vdoa, 0, sizeof(vdoa));
+  vdoa.input.width   = vdoa.output.width  = task.currBuf->iWidth;
+  vdoa.input.height  = vdoa.output.height = task.currBuf->iHeight;
+  vdoa.input.format  = task.currBuf->iFormat;
 
   // check for 3-field deinterlace (no HIGH_MOTION allowed) from tile field format
-  if (ipu->previous && ipu->current->iFormat == _4CC('T', 'N', 'V', 'F'))
+  if (task.prevBuf && task.currBuf->iFormat == _4CC('T', 'N', 'V', 'F'))
   {
-    memcpy(&vdoa.input.deinterlace, &ipu->task.input.deinterlace, sizeof(ipu->task.input.deinterlace));
-    memset(&ipu->task.input.deinterlace, 0, sizeof(ipu->task.input.deinterlace));
-    vdoa.input.paddr_n = ipu->current->pPhysAddr;
+    memcpy(&vdoa.input.deinterlace, &task.input.deinterlace, sizeof(task.input.deinterlace));
+    memset(&task.input.deinterlace, 0, sizeof(task.input.deinterlace));
+    vdoa.input.paddr_n = task.currBuf->pPhysAddr;
   }
 
-  struct g2d_buf *conv = g2d_alloc(ipu->current->iWidth *ipu->current->iHeight * 3, 0);
+  struct g2d_buf *conv = g2d_alloc(task.currBuf->iWidth * task.currBuf->iHeight * 3, 0);
   if (!conv)
   {
     CLog::Log(LOGERROR, "iMX: can't allocate crop buffer");
     return false;
   }
 
-  ((CDVDVideoCodecIMXBuffer*)ipu->current)->m_convBuffer = conv;
+  ((CDVDVideoCodecIMXBuffer*)task.currBuf)->m_convBuffer = conv;
 
-  vdoa.input.paddr   = vdoa.input.paddr_n ? ipu->previous->pPhysAddr : ipu->current->pPhysAddr;
+  vdoa.input.paddr   = vdoa.input.paddr_n ? task.prevBuf->pPhysAddr : task.currBuf->pPhysAddr;
   vdoa.output.format = m_fbVar.bits_per_pixel == 16 ? _4CC('Y', 'U', 'Y', 'V') : _4CC('N', 'V', '1', '2');
   vdoa.output.paddr  = conv->buf_paddr;
 
@@ -1771,70 +1771,70 @@ bool CIMXContext::TileTask(IPUTaskPtr &ipu)
     return false;
   }
 
-  ipu->task.input.paddr   = vdoa.output.paddr + pad;
-  ipu->task.input.format  = vdoa.output.format;
-  if (ipu->task.input.deinterlace.enable && ipu->task.input.deinterlace.motion != HIGH_MOTION)
+  task.input.paddr   = vdoa.output.paddr + pad;
+  task.input.format  = vdoa.output.format;
+  if (task.input.deinterlace.enable && task.input.deinterlace.motion != HIGH_MOTION)
   {
-    ipu->task.input.paddr_n = ipu->task.input.paddr;
-    ipu->task.input.paddr   = ipu->previous->pPhysAddr + pad;
+    task.input.paddr_n = task.input.paddr;
+    task.input.paddr   = task.prevBuf->pPhysAddr + pad;
   }
-  ipu->current->iFormat   = vdoa.output.format;
-  ipu->current->pPhysAddr = vdoa.output.paddr;
+  task.currBuf->iFormat   = vdoa.output.format;
+  task.currBuf->pPhysAddr = vdoa.output.paddr;
 
   return true;
 }
 
-bool CIMXContext::DoTask(IPUTaskPtr &ipu, CRect *dest)
+bool CIMXContext::DoTask(IPUTask &task, CRect *dest)
 {
   // Clear page if cropping changes
-  CRectInt dstRect(ipu->task.output.crop.pos.x, ipu->task.output.crop.pos.y,
-                   ipu->task.output.crop.pos.x + ipu->task.output.crop.w,
-                   ipu->task.output.crop.pos.y + ipu->task.output.crop.h);
+  CRectInt dstRect(task.output.crop.pos.x, task.output.crop.pos.y,
+                   task.output.crop.pos.x + task.output.crop.w,
+                   task.output.crop.pos.y + task.output.crop.h);
 
   // Populate input block
-  ipu->task.input.width   = ipu->current->iWidth;
-  ipu->task.input.height  = std::min(ipu->current->iHeight, (unsigned int)1080);
-  ipu->task.input.format  = ipu->current->iFormat;
-  ipu->task.input.paddr   = ipu->current->pPhysAddr;
+  task.input.width   = task.currBuf->iWidth;
+  task.input.height  = std::min(task.currBuf->iHeight, (unsigned int)1080);
+  task.input.format  = task.currBuf->iFormat;
+  task.input.paddr   = task.currBuf->pPhysAddr;
 
-  ipu->task.output.width  = m_fbWidth;
-  ipu->task.output.height = m_fbHeight;
-  ipu->task.output.format = m_fbVar.nonstd;
-  ipu->task.output.paddr  = m_fbPhysAddr + ipu->page*m_fbPageSize;
+  task.output.width  = m_fbWidth;
+  task.output.height = m_fbHeight;
+  task.output.format = m_fbVar.nonstd;
+  task.output.paddr  = m_fbPhysAddr + task.targetPage * m_fbPageSize;
 
-  if (m_pageCrops[ipu->page] != dstRect)
+  if (m_pageCrops[task.targetPage] != dstRect)
   {
-    m_pageCrops[ipu->page] = dstRect;
-    Clear(ipu->page);
+    m_pageCrops[task.targetPage] = dstRect;
+    Clear(task.targetPage);
   }
 
-  if ((ipu->task.input.crop.w <= 0) || (ipu->task.input.crop.h <= 0)
-  ||  (ipu->task.output.crop.w <= 0) || (ipu->task.output.crop.h <= 0))
+  if ((task.input.crop.w <= 0) || (task.input.crop.h <= 0)
+  ||  (task.output.crop.w <= 0) || (task.output.crop.h <= 0))
     return false;
 
-  int ret = !TileTask(ipu);
+  int ret = !TileTask(task);
   if (!ret)
   {
     //We really use IPU only if we have to deinterlace (using VDIC)
     ret = IPU_CHECK_ERR_INPUT_CROP;
     while (ret > IPU_CHECK_ERR_MIN)
     {
-        ret = ioctl(m_ipuHandle, IPU_CHECK_TASK, &ipu->task);
+        ret = ioctl(m_ipuHandle, IPU_CHECK_TASK, &task);
         switch (ret)
         {
         case IPU_CHECK_OK:
             break;
         case IPU_CHECK_ERR_SPLIT_INPUTW_OVER:
-            ipu->task.input.crop.w -= 8;
+            task.input.crop.w -= 8;
             break;
         case IPU_CHECK_ERR_SPLIT_INPUTH_OVER:
-            ipu->task.input.crop.h -= 8;
+            task.input.crop.h -= 8;
             break;
         case IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER:
-            ipu->task.output.crop.w -= 8;
+            task.output.crop.w -= 8;
             break;
         case IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER:
-            ipu->task.output.crop.h -= 8;
+            task.output.crop.h -= 8;
             break;
         // deinterlacing setup changing, m_ipuHandle is closed
         case -1:
@@ -1845,7 +1845,7 @@ bool CIMXContext::DoTask(IPUTaskPtr &ipu, CRect *dest)
         }
     }
 
-    ret = ioctl(m_ipuHandle, IPU_QUEUE_TASK, &ipu->task);
+    ret = ioctl(m_ipuHandle, IPU_QUEUE_TASK, &task);
     if (ret < 0)
       CLog::Log(LOGERROR, "IPU task failed: %s at #%d\n", strerror(errno), __LINE__);
   }
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h
index 69a74fe..88aa06f 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h
@@ -137,32 +137,26 @@ public:
   static const int  m_fbPages;
 
 private:
-  struct IPUTask
+  struct IPUTask : public ipu_task
   {
-    IPUTask(CIMXBuffer *buffer_p, CIMXBuffer *buffer, int p = 0)
-      : previous(buffer_p), current(buffer), page(p)
+    IPUTask(CIMXBuffer *buffer_p, CIMXBuffer *buffer, int page)
+      : prevBuf(buffer_p), currBuf(buffer), targetPage(page)
     {
-      memset(&task, 0, sizeof(task));
+      memset(this, 0, sizeof(ipu_task));
     }
 
     // Kept for reference
-    CIMXBuffer *previous;
-    CIMXBuffer *current;
+    CIMXBuffer *prevBuf;
+    CIMXBuffer *currBuf;
 
-    // The actual task
-    struct ipu_task task;
-
-    unsigned int page;
-    int shift = true;
+    int targetPage;
   };
 
-  typedef std::shared_ptr<struct IPUTask> IPUTaskPtr;
-
   bool GetFBInfo(const std::string &fbdev, struct fb_var_screeninfo *fbVar);
 
-  void PrepareTask(IPUTaskPtr &ipu, CRect srcRect, CRect dstRect);
-  bool DoTask(IPUTaskPtr &ipu, CRect *dest = nullptr);
-  bool TileTask(IPUTaskPtr &ipu);
+  void PrepareTask(IPUTask &task, CRect srcRect, CRect dstRect);
+  bool DoTask(IPUTask &task, CRect *dest = nullptr);
+  bool TileTask(IPUTask &task);
 
   void SetFieldData(uint8_t fieldFmt, double fps);
 
-- 
1.9.1

